# 2022-02-14

# 2차원 배열

- **입력 받기**

  - ```python
    3
    1 2 3
    4 5 6
    7 8 9
    N = int(input())
    arr = [list(map(int, input().split())) for _ in range(N)]
    print(arr)
    >> [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    ```

  - ```python
    3
    123
    456
    789
    N = int(input())
    arr = [list(map(int, input())) for _ in range(N)]
    print(arrs)
    >> [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    ```

- **접근**

  - 행 우선 순회 (행, 열 정확하게 파악하기)

  - 열 우선 순회 (행, 열 정확하게 파악하기)

  - 지그재그 순회

  - 델타 이용

    - ```python
      # 1.
      di = [0, 1, 0, -1]
      dj = [1, 0, -1, 0]
      for k in range(4):
          ni = i + di[k]
          nj = j + dj[k]
          if 0 <= ni < N and 0 <= nj < M: # 유효인덱스
              arr[ni][nj]
      
      # 2.
      for di, dj in [(0,1), (1,0), (0,-1), (-1,0)]:
          ni = i + di
          nj = j + dj
          if 0 <= ni < N and 0 <= nj < M: # 유효인덱스
              arr[ni][nj]
      ```

    - 대각선 델타

    - 여러 칸 떨어진 델타

    - 8방향 델타...

- **전치행렬**

  - ```python
    arr = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
    ]
    for i in range(3):
        for j in range(3):
            if i < j:
                arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
       
    >>> arr = [
    [1, 4, 7],
    [2, 5, 8],
    [3, 6, 9]
    ]
    ```

  - ```python
    # 오른쪽 대각선 기준 전치 행렬
    a = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12],
    [13, 14, 15, 16]
    ]
    
    for i in range(4):
        for j in range(4):
            if j < 3-i:
                a[i][j], a[3-j][3-i] = a[3-j][3-i], a[i][j]
    
    >>> arr = [
    [16, 12, 8, 4],
    [15, 11, 7, 3],
    [14, 10, 6, 2],
    [13, 9, 5, 1]
    ]
    ```

# 비트 연산자

- & : 비트 단위로 AND 연산

- | : 비트 단위로 OR 연산

- `<< `: 피연산자의 비트 열을 왼쪽으로 이동시킴

- `>>` : 피연산자의 비트열을 오른쪽으로 이동시킴

- ```python
  # 태경표 예상문제
  1 << n : 2**n, 즉 원소가 n개일 경우의 모든 부분 집합의 수를 의미
  i & (1<<j) : i의 j번째 비트가 1인지 아닌지를 검사
      - 1<<j : j번 비트만 1인 값(나머지 비트는 모두 0)
  ```

- ```python
  arr = [3, 6, 7, 1, 5, 4]
  
  n = len(arr)
  
  for i in range(1<<n): # 부분집합의 개수
      for j in range(n): # 원소의 수만큼 비트를 비교
          if i & (i<<j): # i의 j번 비트가 1인 경우
              print(arr[j], end=',') # j번 원소 출력
      print()
  print()
  ```

# 검색

- **순차검색, 이진검색 구현할 줄 알아야 함**

- **순차 검색**

  - 일렬로 되어 있는 자료를 순서대로 검색하는 방법

  - 검색 대상의 수가 많은 경우에는 비효율적

  - **정렬되어 있지 않은 경우**

    - 첫번째 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교하며 찾는다

    - 자료 구조의 마지막에 이를 때까지 검색 대상을 찾지 못하면 검색 실패

    - 찾고자 하는 원소의 순서에 따라 비교 횟수가 결정됨

      - 평균 비교 횟수 : (1+2+3+..+n) / n = (n+1) / 2

    - 시간 복잡도 : O(n)

    - 구현할 때 while문 등의 조건에서는 인덱스 범위 안 벗어나는지를 먼저 확인

      - ```python
        # i<n이 인덱스 조건이니까 먼저 들어가야 함
        while i<n and a[i]!=key:
        ```

  - **정렬되어 있는 경우**

    - 오름차순으로 정렬된 상태에서 검색 실시한다고 가정
    - 자료를 순차적으로 검색하면서 키 값을 비교하여, 원소의 키 값이 검색 대상의 키 값보다 크면 찾는 원소가 없다는 것이므로 더 이상 검색을 하지 않고 중단
    - 검색 실패를 반환하는 경우 평균 비교 횟수가 반으로 줄어듦
    - 시간 복잡도 : O(n)

- **이진 검색**
  - 자료의 **가운데**에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행
  - 목적 키를 찾을 때까지 이진 검색을 순환적으로 반복 수행함으로써 검색 범위를 반으로 줄여가며 보다 빠르게 검색 수행
  - **자료가 정렬된 상태여야 함**
  - 시간 복잡도 : O(log n)
  - 구현
    - 검색 범위의 시작점과 종료점을 이용하여 검색 반복 수행
    - 자료에 삽입이나 삭제가 발생했을 때 배열의 상태를 항상 정렬 상태로 유지하는 추가 작업 필요
    - 재귀 함수로도 구현 가능 (근데 안 할거얌~~~~오래 걸령~~~~)

# 정렬

- **버블 소트랑 선택 정렬은 기억해 두기 (차이점, 그림, 구현 방법 숙지!)**  
  - 버블 소트는 구간의 끝이 점점 앞으로 옴
  - 선택 정렬은 구간의 시작이 점점 뒤로 감

- **선택 정렬**
  - 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치 교환
    - 주어진 리스트 중에서 최솟값 찾기 (인덱스도 알아야 함)
    - 그 값을 리스트의 맨 앞에 위치한 값과 교환
    - 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정 반복
  - 시간 복잡도 : O(n**2)

# 셀렉션 알고리즘

- 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법
  - 최댓값, 최솟값, 중간값 찾는 알고리즘을 의미하기도 함
- 선택 과정
  - 정렬 알고리즘을 이용하여 자료 정렬하기
  - 원하는 순서에 있는 원소 가져오기
- k번째로 작은 원소 찾기
  - 모두 정렬할 필요 없음
  - 1번부터 k번째까지 작은 원소들을 찾아 배열의 앞으로 이동시켜 k번째 반환
  - k가 비교적 작을 때 유용
  - O(kn)의 수행시간

# 정렬 알고리즘 비교

| 알고리즘    | 평균 수행시간 | 최악 수행시간 | 알고리즘 기법 | 비고                                    |
| ----------- | ------------- | ------------- | ------------- | --------------------------------------- |
| 버블 정렬   | O(n**2)       | O(n**2)       | 비교와 교환   | 코딩이 가장 손쉽다.                     |
| 카운팅 정렬 | O(n+k)        | O(n+k)        | 비교환 방식   | n이 비교적 작을 때만 가능하다.          |
| 선택 정렬   | O(n**2)       | O(n**2)       | 비교와 교환   | 교환의 횟수가 버블, 삽입 정렬보다 작다. |
| 퀵 정렬     | O(nlogn)      | O(n**2)       | 분할 정복     | 평균적으로는 가장 빠르다.               |
| 삽입 정렬   | O(n**2)       | O(n**2)       | 비교와 교환   | n의 개수가 작을 때 효과적이다.          |
| 병합 정렬   | O(nlogn)      | O(nlogn)      | 분할 정복     | 연결리스트의 경우 가장 효과적인 방식    |

