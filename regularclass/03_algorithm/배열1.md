# 2022-02-09

# 알고리즘

- 알고리즘 : 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
  - 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법
- 알고리즘의 성능 분석
  - 작업량 : 시간복잡도로 표현
    - **시간 복잡도**
      - 실제 걸리는 시간을 측정
      - 실행되는 명령문의 개수를 계산
      - 빅-오(O) 표기법
        - 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
        - 계수는 생략

# 배열

- 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료 구조

# 정렬

- 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값 (오름차순), 혹은 그 반대의 순서대로 (내림차순) 재배열하는 것
- 키 : 자료를 정렬하는 기준이 되는 특정 값

## 버블 정렬

- 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

1. 첫 번째 원소부터 **인접한 원소끼리 계속 자리를 교환**하면서 맨 마지막 자리까지 이동
2. **한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬됨**

- 시간 복잡도 : O(n**2)



## 카운팅 정렬

- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
- 제한 사항
  - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
  - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함
- 시간 복잡도 : O(n+k) (n : 리스트 길이, k : 정수의 최댓값)

1. 각 항목들의 **발생 횟수**를 세고, 정수 항목들로 직접 인덱스 되는 **카운트 배열**에 저장

   - data = [0, 4, 1, 3, 1, 2, 4, 1]

   - counts = [1, 3, 1, 1, 2]  <- 데이터의 각 항목과 일치하는 번호의 인덱스에 개수 저장

2. 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 카운트 배열의 원소 조정

   - data = [0, 4, 1, 3, 1, 2, 4, 1]

   - counts = [1, 4, 5, 6, 8]  <- **누적 합** 저장

3. data의 맨 끝 원소부터 확인하며 counts를 줄여나가고 temp에 저장

   - data = [0, 4, 1, 3, 1, 2, 4, **1**]
   - counts = [1, 3, 5, 6, 8]  <- count[1]에서 하나 줄이면서 temp의 4번째 칸에 1 넣어주기
   - temp = [ _, _, _, 1, _, _, _, _ ]  <- temp의 길이는 counts의 맨 마지막 항목과 같음

4. data = [0, 4, 1, 3, 1, 2, **4**, 1]

   counts = [1, 3, 5, 6, 7]

   temp = [ _, _, _, 1, _, _, _, 4] 

5. data = [0, 4, 1, 3, 1, **2**, 4, 1]

   counts = [1, 3, 4, 6, 7]

   temp = [ _, _, _, 1, 2, _, _, 4] 

6. data = [0, 4, 1, 3, **1**, 2, 4, 1]

   counts = [1, 2, 4, 6, 7]

   temp =  [ _, _, 1, 1, 2, _, _, 4] 

7. data = [0, 4, 1, **3**, 1, 2, 4, 1]

   counts = [1, 2, 4, 5, 7]

   temp = [ _, _, 1, 1, 2, 3, _, 4] 

8. data = [0, 4, **1**, 3, 1, 2, 4, 1]

   counts = [1, 1, 4, 5, 7]

   temp = [ _, 1, 1, 1, 2, 3, _, 4] 

9. data = [0, **4**, 1, 3, 1, 2, 4, 1]

   counts = [1, 1, 4, 5, 6]

   temp = [ _, 1, 1, 1, 2, 3, 4, 4] 

10. data = [**0**, 4, 1, 3, 1, 2, 4, 1]

    counts = [0, 1, 4, 5, 6]

    temp = [ 0, 1, 1, 1, 2, 3, 4, 4] 

    

## 선택 정렬

## 퀵 정렬

## 삽입 정렬

## 병합 정렬

# 완전 검색

- 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
- Brute-force 혹은 generate-and-test 기법이라고도 불림

# 탐욕 알고리즘

- 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달
- 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없다.

1. 해 선택
   - 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분 해 집합에 추가
2. 실행 가능성 검사
   - 새로운 부분 해 집합이 실행 가능한지 확인
3. 해 검사
   - 새로운 부분 해 집합이 문제의 해가 되는지 확인

